package brp.rules.positives;

import java.beans.beancontext.BeanContext;

import java.beans.beancontext.BeanContextServices;
import java.beans.beancontext.BeanContextServicesSupport;
import java.util.AbstractCollection;
import java.util.AbstractQueue;
import java.util.AbstractSequentialList;
import java.util.AbstractSet;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.NavigableSet;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.SortedSet;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TransferQueue;
import javax.management.relation.RoleList;
import javax.management.relation.RoleUnresolvedList;
import javax.print.attribute.standard.JobStateReasons;

public class ViolationsMethod {

    public void violations(
            BeanContext beanContext,
            BeanContextServices contextServices,
            BlockingDeque<String> blockingDeque,
            BlockingQueue<String> blockingQueue,
            List<String> list,
            NavigableSet<String> navigableSet,
            Queue<String> queue,
            Set<String> set,
            SortedSet<String> sortedSet,
            TransferQueue<String> transferQueue,
            AbstractCollection<String> abstractCollection,
            AbstractQueue<String> abstractQueue,
            AbstractSequentialList<String> sequentialList,
            AbstractSet<String> abstractSet,
            ArrayBlockingQueue<String> arrayBlockingQueue,
            ArrayDeque<String> arrayDeque,
            ArrayList<String> arrayList,
            BeanContextServicesSupport servicesSupport,
            BeanContext beanContextSupport,
            ConcurrentHashMap.KeySetView<String, Boolean> keySet,
            ConcurrentLinkedDeque<String> concurrentLinkedDeque,
            ConcurrentLinkedQueue<String> concurrentLinkedQueue,
            ConcurrentSkipListSet<String> concurrentSkipListSet,
            CopyOnWriteArrayList<String> copyOnWriteArrayList,
            CopyOnWriteArraySet<String> copyOnWriteArraySet,
            DelayQueue<MyDelayed> delayQueue,
            EnumSet<MyEnum> enums,
            HashSet<String> hashSet,
            JobStateReasons reasons,
            LinkedBlockingDeque<String> linkedBlockingDeque,
            LinkedBlockingQueue<String> linkedBlockingQueue,
            LinkedHashSet<String> linkedHashSet,
            LinkedList<String> linkedList,
            LinkedTransferQueue<String> linkedTransferQueue,
            PriorityBlockingQueue<String> priorityBlockingQueue,
            PriorityQueue<String> priorityQueue,
            RoleList roleList,
            RoleUnresolvedList roleUnresolvedList,
            Stack<String> stack,
            SynchronousQueue<String> synchronousQueue,
            TreeSet<String> treeSet,
            Vector<String> vector,
            Collection<String> collection
    ){
        if (beanContext.size()  == 0) {
            System.out.println("is empty");
        }

        if (contextServices.size() == 0) {
            System.out.println("is empty");
        }

        if (blockingDeque.size() == 0) {
            System.out.println("is empty");
        }

        if (blockingQueue.size() == 0) {
            System.out.println("is empty");
        }

        if (list.size() == 0){
            System.out.println("is empty");
        }

        if ((navigableSet.size() == 0)) {
            System.out.println("is empty");
        }

        if (queue.size() == 0){
            System.out.println("is empty");
        }

        if (set.size() == 0){
            System.out.println("is empty");
        }

        if (sortedSet.size() == 0){
            System.out.println("is empty");
        }

        if (transferQueue.size() == 0){
            System.out.println("is empty");
        }

        if (abstractCollection.size() == 0){
            System.out.println("is empty");
        }

        if (abstractQueue.size() == 0){
            System.out.println("is empty");
        }

        if (sequentialList.size() == 0){
            System.out.println("is empty");
        }

        if (abstractSet.size() == 0){
            System.out.println("is empty");
        }

        if (arrayBlockingQueue.size() == 0){
            System.out.println("is empty");
        }

        if (arrayDeque.size() == 0){
            System.out.println("is empty");
        }

        if (arrayList.size() == 0){
            System.out.println("is empty");
        }

        if (servicesSupport.size() == 0){
            System.out.println("is empty");
        }

        if (beanContextSupport.size() == 0){
            System.out.println("is empty");
        }

        if (keySet.size() == 0){
            System.out.println("is empty");
        }

        if (concurrentLinkedDeque.size() == 0){
            System.out.println("is empty");
        }

        if (concurrentLinkedQueue.size() == 0){
            System.out.println("is empty");
        }

        if (concurrentSkipListSet.size() == 0){
            System.out.println("is empty");
        }

        if (copyOnWriteArrayList.size() == 0){
            System.out.println("is empty");
        }

        if (copyOnWriteArraySet.size() == 0){
            System.out.println("is empty");
        }

        if (delayQueue.size() == 0){
            System.out.println("is empty");
        }

        if (enums.size() == 0){
            System.out.println("is empty");
        }

        if (hashSet.size() == 0){
            System.out.println("is empty");
        }

        if (reasons.size() == 0){
            System.out.println("is empty");
        }

        if (linkedBlockingDeque.size() == 0){
            System.out.println("is empty");
        }

        if (linkedBlockingQueue.size() == 0){
            System.out.println("is empty");
        }

        if (linkedHashSet.size() == 0){
            System.out.println("is empty");
        }

        if (linkedList.size() == 0){
            System.out.println("is empty");
        }

        if (linkedTransferQueue.size() == 0){
            System.out.println("is empty");
        }

        if (priorityBlockingQueue.size() == 0){
            System.out.println("is empty");
        }

        if (priorityQueue.size() == 0){
            System.out.println("is empty");
        }

        if (roleList.size() == 0){
            System.out.println("is empty");
        }

        if (roleUnresolvedList.size() == 0){
            System.out.println("is empty");
        }

        if (stack.size() == 0){
            System.out.println("is empty");
        }

        if (synchronousQueue.size() == 0){
            System.out.println("is empty");
        }

        if (treeSet.size() == 0){
            System.out.println("is empty");
        }

        if (vector.size() == 0){
            System.out.println("is empty");
        }

        if (collection.size() == 0){
            System.out.println("is empty");
        }
    }
}
